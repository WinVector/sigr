---
title: "Bias Ests"
output: github_document
---

```{r}
library("rqdatatable")

set.seed(32535)

naive_sd_fun <- function(x) {
  sqrt(mean((mean(x)-x)^2))
}
  
sd_attinuation_binomial <- function(k, n, sd_fun) {
  obs <- 0:n
  probs <- dbinom(obs, size = n, prob = k/n)
  sds <- vapply(obs,
                function(ki) {
                  sd_fun(c(rep(1, ki), rep(0, n-ki)))
                }, numeric(1))
  observed <- sum(probs*sds)
  sd_target <- sd_fun(c(rep(1, k), rep(0, n-k)))
  attenuation <- observed/sd_target
  attenuation
}

mk_scale_adjustment_table <- function(n, sd_fun) {
  v <- vapply(0:n,
         function(k) {
           1/sd_attinuation_binomial(k, n, sd_fun)
         }, numeric(1))
  # can't correct 0 or all cases- just put a nice value there.
  v[is.na(v) | is.nan(v) | is.infinite(v) | (v<=0)] <- max(v, na.rm = TRUE)
  v
}

data <- as.data.frame(Titanic)

data <- data %.>% 
  select_rows_nse(., 
                  (Class == "Crew") & 
                    (Sex == "Female") & 
                    (Age == "Adult")) %.>%
  orderby(., "Survived")

print(data)

universe <- c(rep(0, data$Freq[data$Survived=="No"]),
              rep(1, data$Freq[data$Survived=="Yes"]))

print(universe)



summary1 <- function(x, scale_adjustment_table) {
  naive_var <- mean((mean(x)-x)^2)
  sd_est <- sd(x)
  # https://en.wikipedia.org/wiki/Unbiased_estimation_of_standard_deviation
  # correctly correct for normal, not binomomial as we have here!
  if(length(scale_adjustment_table) != (1+length(x))) {
    stop("wrong sized scale_adjustment table")
  }
  data.frame(mean = mean(x),
             var = var(x),
             sd = sd_est,
             naive_var = naive_var,
             naive_sd = sqrt(naive_var),
             adj_sd = sqrt(naive_var)*scale_adjustment_table[[sum(x)+1]])
}

su <- summary1(
  universe, 
  mk_scale_adjustment_table(length(universe), naive_sd_fun))
print(su)

n <- length(universe)
Bessel_corrected_var <- (n/(n-1))*su$naive_var
print(Bessel_corrected_var)

Bessel_corrected_sd <- sqrt(Bessel_corrected_var)
print(Bessel_corrected_sd)


mk_f <- function(universe, samp_size, summary1) {
  force(universe)
  force(samp_size)
  force(summary1)
  scale_adjustment_table <- 
    mk_scale_adjustment_table(samp_size, naive_sd_fun)
  f <- function(i) {
    sample <- universe[sample.int(length(universe), 
                                  samp_size, 
                                  replace = TRUE)]
    summary1(sample, scale_adjustment_table)
  }
}

f <- mk_f(universe, 5, summary1)


cl <- parallel::makeCluster(parallel::detectCores())
res <- parallel::parLapply(cl, 1:10000, f)
res <- do.call(rbind, res)

as.data.frame(lapply(res, mean))
```

