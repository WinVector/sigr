---
title: "Untitled"
output: github_document
---

```{r}
library(wrapr)
library(sigr)
library(rquery)
library(cdata)
library(ggplot2)
library(boot)
       
set.seed(2020)
y_example <- function(n, prevalence = 0.5) {
  data.frame(
    y = sample(
      c(TRUE, FALSE), 
      size = n, 
      replace = TRUE,
      prob = c(prevalence, 1 - prevalence))
  )
}
beta_variable <- function(
  d, 
  shape1_pos, shape2_pos, 
  shape1_neg, shape2_neg) {
  score <- numeric(nrow(d))
  score[d$y] <- rbeta(sum(d$y), shape1 = shape1_pos, shape2 = shape2_pos)
  score[!d$y] <- rbeta(sum(!d$y), shape1 = shape1_neg, shape2 = shape2_neg)
  score
}
#
# generate the example. This looks complicated, but we are trying to generate
# predictions consistent with a calibrated model (like logistic regression)
#
prevalence <- 0.01
a_pos <- 6
b_pos <- 300
a_neg <- 3
p_odds_ratio <- prevalence / (1-prevalence)
pos_mean <- a_pos / (a_pos + b_pos)
b_neg <- a_neg * (  1 / (p_odds_ratio * (1 - pos_mean)) - 1)
stopifnot(b_neg >= 0)
neg_mean <- a_neg / (a_neg + b_neg)
check_p <- prevalence * pos_mean + (1 - prevalence) * neg_mean
stopifnot(abs(prevalence - check_p) < 1e-5)
d <- y_example(10000, prevalence = prevalence)
d$predicted_probability <- beta_variable(
  d,
  shape1_pos = a_pos, 
  shape2_pos = b_pos,
  shape1_neg = a_neg,
  shape2_neg = b_neg)
# change the column name to better match the example
colnames(d) <- c("converted", "predicted_probability")

# utilities
d$true_positive_value <- 100 - 5   # net revenue - cost
d$false_positive_value <- -5       # the cost of a call
d$true_negative_value <-  0.01     # a small reward for getting them right
d$false_negative_value <- -0.01    # a small penalty for having missed them

# actual values
values <- model_utility(d, 'predicted_probability', 'converted')

best_idx <- which.max(values$total_value)
knitr::kable(values[best_idx, ])
chosen_threshold <- values$threshold[[best_idx]]
print(chosen_threshold)

threshold_list <- chosen_threshold + seq(-0.01, 0.01, by = 0.001)

f <- function(d, indices, ...) {
  vi <- model_utility(d[indices, ], 'predicted_probability', 'converted')
  ret <- numeric(length(threshold_list))
  for(i in seq_len(length(threshold_list))) {
    ii <- which.min(abs(vi$threshold - threshold_list[[i]]))
    ret[[i]] <- vi$total_value[[ii]]
  }
  ret
}

boot_stats <- boot(data = d, statistic = f, R = 1000)
boot_data <- as.data.frame(boot_stats$t)
colnames(boot_data) <- threshold_list
boot_data <- pivot_to_blocks(boot_data, 
                            nameForNewKeyColumn = 'threshold', 
                            nameForNewValueColumn = 'total_value', 
                            columnsToTakeFrom = colnames(boot_data))
boot_data$threshold <- as.numeric(boot_data$threshold)

q_0.025 <- function(x) { quantile(x, probs = 0.025) }
q_0.25 <- function(x) { quantile(x, probs = 0.25) }
q_0.50 <- function(x) { quantile(x, probs = 0.50) }
q_0.75 <- function(x) { quantile(x, probs = 0.75) }
q_0.975 <- function(x) { quantile(x, probs = 0.975) }
boot_summary <- project(boot_data,
                        mean_total_value = mean(total_value),
                        q_0.025 = q_0.025(total_value),
                        q_0.25 = q_0.25(total_value),
                        q_0.50 = q_0.50(total_value),
                        q_0.75 = q_0.75(total_value),
                        q_0.975 = q_0.975(total_value),
                        groupby = 'threshold') %.>%
  orderby(., 'threshold')

value_range <- values[
  (values$threshold >= min(threshold_list)) &
     (values$threshold <= max(threshold_list)), ]

ggplot() +
  geom_ribbon(
    data = boot_summary,
    mapping = aes(x = threshold, ymin = q_0.025, ymax = q_0.975),
    alpha = 0.2,
    fill = 'blue') +
  geom_ribbon(
    data = boot_summary,
    mapping = aes(x = threshold, ymin = q_0.25, ymax = q_0.75),
    alpha = 0.3,
    fill = 'green') +
  geom_point(
    data = value_range,
    mapping = aes(x = threshold, y = total_value)) + 
  geom_line(
    data = boot_summary,
    mapping = aes(x = threshold, y = mean_total_value),
    color = 'red') + 
  geom_vline(xintercept = chosen_threshold) +
  ggtitle("actual versus bootstrap re-sampled utility by threshold")
```

